{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"About zkFold","text":"<p>zkFold is developing scaling solutions for blockchains, zero knowledge proof (ZKP) infrastructure and development tools. To achieve this goal, we use novel approaches to distributed system design and base our products on the state-of-the-art ZKP algorithms.</p> <p>Our core team consists of talented developers and researchers who are passionate about distributed ledger technology (DLT) and zero knowledge cryptography. The team's expertise spans a wide range of fields, including cryptography, formal methods, game theory, distributed systems, and programming languages.</p> <p>Contact email: info@zkfold.io.</p>"},{"location":"products/","title":"zkFold Products","text":""},{"location":"products/#zkfold-symbolic","title":"zkFold Symbolic","text":""},{"location":"products/#zkfold-rollup","title":"zkFold Rollup","text":""},{"location":"products/#other-zkapps","title":"Other zkApps","text":""},{"location":"other-zkapps/","title":"zkApps designed by zkFold","text":""},{"location":"other-zkapps/mithril-bridge/","title":"Blockchain Bridge Based on Mithril Signatures","text":""},{"location":"other-zkapps/p2p-on-ramp/","title":"P2P Fiat-to-Crypto On-Ramp Application","text":""},{"location":"other-zkapps/wallet-backend/","title":"Smart Contract Wallet Backend","text":""},{"location":"other-zkapps/wallet-backend/#overview","title":"Overview","text":"<p>The Smart Contract Wallet Backend is an implementation of a programmable wallet with an extensible API and feature set that uses zkFold Symbolic framework. It includes all necessary components for a wallet application except the graphical user interface. The wallet backend is packaged as a WASM module that can be integrated into any browser-based wallet application.</p>"},{"location":"other-zkapps/wallet-backend/#wallet-instructions","title":"Wallet Instructions","text":"<p>The smart contract wallet's extensible functionality is based on the idea of wallet instructions. A wallet instruction is a piece of code in the form of an arithmetic circuit that can be signed by the wallet owner. More specifically, a wallet instruction must be of the format that is used in the Symbolic Verifier. To spend a wallet UTxO, a Symbolic Verifier proof for some wallet instruction must be verified on-chain.</p> <p>Wallet instructions enables programming spending logic for the wallet UTxOs \"on-the-fly\". For example, an atomic swap between two users can be performed in an asyncronous way and without any on-chain setup: both users can sign a swap wallet instruction and send it to the order aggregator. Once the aggregator identifies a pair of instructions that can be matched against each other, it can submit the atomic swap transaction to the blockchain.</p>"},{"location":"other-zkapps/wallet-backend/#features","title":"Features","text":""},{"location":"other-zkapps/wallet-backend/#web2-login","title":"Web2 Login","text":"<p>The Smart Contract Wallet Backend enables spending of the wallet's UTxOs using Web2 authentification tokens. This feature enables cryptocurrency wallets without a seed phrase which simplify the user experience for new Web3 users.</p> <p>First, the wallet backend creates an address that is associated with the user's Web2 account. Then, the user can spend funds from that address by logging in with their Web2 account and proving that they know an active Web2 token that is associated with the account.</p>"},{"location":"other-zkapps/wallet-backend/#babel-fees","title":"Babel Fees","text":"<p>Babel fees are a way to pay for the transaction fees in a different token than the native token of the blockchain.</p> <p>The aggregation server can accept transaction requests where fees are paid in different tokens. The server can then match it with the known set of Babel fees instructions. This adds extra inputs and outputs to the transaction to balance it out so that the resulting fee is paid in ada</p>"},{"location":"other-zkapps/wallet-backend/#sponsored-transactions","title":"Sponsored Transactions","text":"<p>Sponsored transactions are a way for a third party to pay for the transaction fees of a user. The third party can be, for example, a wallet provider, a dApp, or a recipient of a payment.</p> <p>By submitting instructions to the aggregation server, the third party can sponsor the transaction fees of the user from their own funds. It is possible to set up various conditions for the sponsorship, such as the maximum amount of sponsored fees per transaction, the maximum number of transactions per day, etc.</p>"},{"location":"other-zkapps/wallet-backend/#multi-user-transactions","title":"Multi-User Transactions","text":"<p>Users of wallets based on the Smart Contract Wallet Backend can create multi-user transactions in a convenient asynchronous way where every user can sign their part of the transaction independently.</p> <p>The aggregation server can collect the signed parts of the transaction from the users and submit the full transaction to the blockchain once all parts are collected. This feature is useful for atomic swaps, escrow transactions, and other multi-user transactions. It also helps in reducing the transaction fees for the users.</p>"},{"location":"other-zkapps/wallet-backend/#apis","title":"APIs","text":"<p>Smart Contract Wallet Backend provides two APIs: the standard CIP-30 Wallet API and the Symbolic Wallet API.</p>"},{"location":"other-zkapps/wallet-backend/#cip-30-wallet-api","title":"CIP-30 Wallet API","text":"<p>The CIP-30 Wallet API is the standard wallet API that is implemented by most of the wallets in the Cardano ecosystem. The API is based on the Cardano Improvement Proposal 30 (CIP-30) and provides a set of functions for managing the wallet's UTxOs. The Smart Contract Wallet Backend implements the full CIP-30 Wallet API. Specifically, the API object provides the following methods:</p> <ul> <li><code>getExtensions</code>: Get the list of the enabled API extensions.</li> <li><code>getNetworkId</code>: Get the current network ID.</li> <li><code>getUtxos</code>: Get the list of the wallet's UTxOs.</li> <li><code>getCollateral</code>: Get the list of the wallet's collateral UTxOs.</li> <li><code>getBalance</code>: Get the balance of the wallet.</li> <li><code>getUsedAddresses</code>: Get the list of the wallet's used addresses.</li> <li><code>getUnusedAddresses</code>: Get the list of the wallet's unused addresses.</li> <li><code>getChangeAddress</code>: Get the wallet's change address.</li> <li><code>getRewardAddresses</code>: Get the list of the wallet's reward addresses.</li> <li><code>signTx</code>: Sign a transaction.</li> <li><code>signData</code>: Sign data.</li> <li><code>submitTx</code>: Submit a transaction to the blockchain.</li> </ul> <p>To create an API object from the Wallet Backend object, use the <code>cip30</code> function.</p> <p>You can find the full specification of the CIP-30 Wallet API here.</p>"},{"location":"other-zkapps/wallet-backend/#symbolic-wallet-api","title":"Symbolic Wallet API","text":"<p>The Symbolic Wallet API provides the additional functionality that is specific to the Smart Contract Wallet Backend. Below we give the reference implementation of the Symbolic Wallet API in Haskell.</p> <p>The following data types are used in the Symbolic Wallet API:</p> <ul> <li><code>Wallet</code>: A wallet object.</li> <li><code>Address</code>: A wallet address.</li> <li><code>Instruction</code>: A wallet instruction. It is a piece of code that describes the spending logic for the wallet UTxOs.</li> <li><code>InstructionId</code>: An instruction identifier that is derived from the instruction object by hashing.</li> <li><code>InstructionInput</code>: An input for a wallet instruction. It is a piece of data that is required to verify the instruction.</li> </ul> <p>The following methods are available as a part of Symbolic Wallet API:</p> Haskell<pre><code>signInstruction :: Wallet -&gt; Instruction -&gt; IO Signature\n</code></pre> <p>Sign a wallet instruction.</p> Haskell<pre><code>submitInstruction :: Address -&gt; Instruction -&gt; Signature -&gt; IO ()\n</code></pre> <p>Submit a wallet instruction to the aggregation server.</p> Haskell<pre><code>submitInstructionInput :: Address -&gt; InstructionId\n    -&gt; InstructionInput -&gt; IO ()\n</code></pre> <p>Submit a wallet instruction input to the aggregation server.</p>"},{"location":"other-zkapps/zk-kyc/","title":"ZK KYC Solution for Cross-Border Payments","text":""},{"location":"other-zkapps/zk-kyc/#_1","title":"zk-kyc","text":""},{"location":"other-zkapps/zkpass/","title":"zkPass Verifier on Cardano","text":""},{"location":"other-zkapps/zkpass/#overview","title":"Overview","text":"<p>zkPass is a protocol for verification of Web2 data in Web3. Specifically, zkPass's Transgate extension and Transgate SDK allow a DApp to verify the result and authenticity of a user's HTTPS communication with a Web2 server. The result, i.e., the HTTPS responses from the server, can then be verified on a blockchain. In this document we introduce zkPass Verifier, a Plutus smart contract that verifies and stores the results of the zkPass protocol on the Cardano blockchain.</p>"},{"location":"other-zkapps/zkpass/#specification","title":"Specification","text":"<p>Verifying computations on Cardano using zero-knowledge cryptography is fairly straightforward. In order to prove that a computation was performed correctly and produced the expected result, one needs to mint a token that is associated with the hash of the computation result. The token is minted if and only if the computation result is verified in a non-interactive zero-knowledge proof protocol. Thus, the token is the proof that the computation was performed correctly. The biggest advantage of this approach is that the Cardano's off-chain infrastructure facilitates querying for the existence of particular tokens on the blockchain making it extremely cheap and efficient to use and re-use the results of the computations.</p> <p>Applying this approach to the zkPass protocol, it makes sense to store the whole zkPass result object as transaction metadata so that it too can be easily fetched by various applications.</p> <p>Below we give the list of conditions that must be satisfied in order to verify the zkPass result on Cardano:</p> <ol> <li>Allocator signature on the task metadata must be correct.</li> <li>The hash of <code>publicFields</code> must be equal to the <code>publicFieldsHash</code> field.</li> <li>Validator signature on the result must be correct.</li> </ol> <p>The zkPass Verifier transactions also include a fee to cover the costs of running zkFold's off-chain infrastructure and zkPass's validator network.</p> <p>The arithmetic circuit expects that the zkPass result object is hashed into a token name using the Poseidon hash function.</p> <p>The zkPass Verifier minting policy is based on the zkFold's Plonk Verifier script.</p> <p>For more information about the zkPass protocol, see the zkPass documentation.</p>"},{"location":"other-zkapps/zkpass/#api","title":"API","text":"<p>The zkPass Verifier API provides functionality for posting and verifying results of zkPass queries on the Cardano blockchain. Below we give the reference implementation of the zkPass Verifier API in Haskell.</p> <p>The following data types are used in the zkPass Verifier API:</p> <ul> <li><code>ZKPassResult</code>: A zkPass result object.</li> </ul> <p>The main data type that is used in the zkPass Verifier API is <code>ZKPassResult</code>. It is defined as follows: Haskell<pre><code>data ZKPassResult = ZKPassResult\n  { allocatorAddress   :: ByteString\n  , allocatorSignature :: ByteString\n  , publicFields       :: ZKPassPublicFields\n  , publicFieldsHash   :: ByteString\n  , taskId             :: ByteString\n  , uHash              :: ByteString\n  , validatorAddress   :: ByteString\n  , validatorSignature :: ByteString\n  }\n</code></pre></p> <p>To construct a transaction that verifier and posts a zkPass result on Cardano, use the following function:</p> Haskell<pre><code>zkPassTransaction :: ZKPassResult -&gt; IO Transaction\n</code></pre> <p>The transaction mints zkPass tokens with the hash of the <code>ZKPassResult</code> as the token name. The tokens are minted if and only if the <code>ZKPassResult</code> object integrity is verified in a non-interactive zero knowledge proof protocol. The transaction can be submitted to the blockchain by normal means.</p> <p>Alternatively, one may use the following function to post a zkPass result on Cardano in a single function call:</p> Haskell<pre><code>postZKPassResult :: ZKPassResult -&gt; IO ()\n</code></pre>"},{"location":"rollup/introduction/","title":"Introduction","text":""},{"location":"rollup/introduction/#what-is-a-zk-rollup","title":"What is a ZK rollup?","text":"<p>A rollup is a blockchain scaling solution where a smart contract (on the underlying blockchain) validates state transitions on a separate ledger (the rollup ledger). In this Layer 2 solution, transactions settle upon a transition of the Layer 1 smart contract to a new state. Smart contract state transitions correspond to the application of transaction batches. As a part of the validation logic, the smart contract verifies the correctness of all transactions in a batch. In ZK rollups, the smart contract uses a zero-knowledge proof protocol to verify the state transitions. The states (or state diffs) of the rollup are posted on-chain as data.</p> <p>Besides the state transition verification, the rollup smart contract is also responsible for briding assets between the L1 chain and the rollup chain. The smart contract can lock assets on the main chain and mint corresponding assets on the rollup chain, and vice versa. Those minted assets are called wrapped tokens. In order to unlock assets on one chain, the wrapped tokens must be burned on the other chain.</p> <p>A rollup does not have its own consensus mechanism. Instead, it relies on the main chain for consensus. The main chain is responsible for finalizing the state updates of the rollup chain. Thus, the finality of the rollup chain cannot be faster than the finality of the main chain.</p>"},{"location":"rollup/introduction/#symbolic-ledger","title":"Symbolic Ledger","text":"<p>Symbolic Ledger is a UTXO-based ledger model created by zkFold that is designed to be efficient for use in zero-knowledge proving protocols. In addition, the ledger rules and on-chain data representation is architectured in a way to minimize communication with the L1 blockchain network, providing exceptional scaling capabilities. The model is generic and can be applied to different blockchains. The key assumptions are that the underlying blockchain can verify zero-knowledge proofs and that the (rollup) data can be posted efficiently on-chain.</p> <p>This ledger model is implemented using the Symbolic framework also developed by zkFold. Any statement about the ledger can be naturally expressed in this framework and automatically converted to an arithmetic circuit for use in zero knowledge proof protocols.</p>"},{"location":"smart-wallet/introduction/","title":"Smart Wallet","text":""},{"location":"smart-wallet/introduction/#overview","title":"Overview","text":"<p>The Smart Contract Wallet Backend (Smart Wallet for short) is a blockchain-agnostic programmable crypto wallet with an extensible feature set packed in a TypeScript library. The library provides a set of APIs to be used by wallet apps.</p> <p>The key features of the Smart Wallet are:</p> <ul> <li>Web2 Login</li> <li>Babel Fees</li> <li>Sponsored Transactions</li> <li>Batch Transactions</li> </ul>"},{"location":"smart-wallet/introduction/#features","title":"Features","text":""},{"location":"smart-wallet/introduction/#web2-login","title":"Web2 Login","text":"<p>The Smart Contract Wallet Backend enables spending of the wallet's UTxOs using Web2 authentification tokens. This feature enables cryptocurrency wallets without a seed phrase which simplify the user experience for new Web3 users.</p> <p>First, the wallet backend creates an address that is associated with the user's Web2 account. Then, the user can spend funds from that address by logging in with their Web2 account and proving that they know an active Web2 token that is associated with the account.</p>"},{"location":"smart-wallet/introduction/#babel-fees","title":"Babel Fees","text":"<p>Babel fees are a way to pay for the transaction fees in a different token than the native token of the blockchain.</p> <p>The aggregation server can accept transaction requests where fees are paid in different tokens. The server can then match it with the known set of Babel fees instructions. This adds extra inputs and outputs to the transaction to balance it out so that the resulting fee is paid in ada</p>"},{"location":"smart-wallet/introduction/#sponsored-transactions","title":"Sponsored Transactions","text":"<p>Sponsored transactions are a way for a third party to pay for the transaction fees of a user. The third party can be, for example, a wallet provider, a dApp, or a recipient of a payment.</p> <p>By submitting instructions to the aggregation server, the third party can sponsor the transaction fees of the user from their own funds. It is possible to set up various conditions for the sponsorship, such as the maximum amount of sponsored fees per transaction, the maximum number of transactions per day, etc.</p>"},{"location":"smart-wallet/introduction/#batch-transactions","title":"Batch Transactions","text":"<p>Users of wallets based on the Smart Contract Wallet Backend can create multi-user transactions in a convenient asynchronous way where every user can sign their part of the transaction independently.</p> <p>The aggregation server can collect the signed parts of the transaction from the users and submit the full transaction to the blockchain once all parts are collected. This feature is useful for atomic swaps, escrow transactions, and other multi-user transactions. It also helps in reducing the transaction fees for the users.</p>"},{"location":"symbolic/introduction/","title":"Introduction","text":""},{"location":"symbolic/introduction/#what-is-zkfold-symbolic","title":"What is zkFold Symbolic?","text":"<p>zkFold Symbolic is a programming framework. It is a subset of Haskell compilable to arithmetic circuits. Symbolic leverages the functional programming paradigm to provide a high-level language for the development of zero knowledge applications. It is designed to be a powerful tool for developers who want to build trustless, decentralized, and privacy-preserving applications and smart contracts.</p> <p>The key design pillars of Symbolic are code efficiency and safety. It is high-level enough to abstract all mathematical nuances of zero knowledge protocols yet extremely efficient with the arithmetic circuits it produces.</p> <p>Traditional performance metrics such as CPU cycles and RAM requirements do not make sense in the context of ZK-programs. Instead, the performance of a compiled circuit is usually measured in the number of additions and multiplications it contains. Symbolic translates the code directly into an arithmetic circuit, avoiding the limitations and inefficiencies of a typical Virtual Machine approach.</p> <p>The idea of the zkFold Symbolic compiler is inspired by symbolic mathematics software packages, such as Wolfram Mathematica. The same abstract Haskell function can be interpreted in two different ways: as a mathematical expression that can be converted to an arithmetic circuit or as an algorithm that produces a concrete numerical output given a concrete input. This approach leads to a more natural and intuitive way of writing zero knowledge programs.</p>"},{"location":"symbolic/introduction/#key-features","title":"Key Features","text":""},{"location":"symbolic/introduction/#high-level-language-with-a-performance-of-a-low-level-one","title":"High-level language with a performance of a low-level one","text":"<p>zkFold Symbolic compiler generally produces near-optimal arithmetic circuits from the high-level Haskell code. Developers are free to implement their custom optimizations and introduce new arithmetizable types using code snippets written in the lower-level eDSL.</p>"},{"location":"symbolic/introduction/#correct-by-construction-arithmetic-circuits","title":"Correct-by-construction arithmetic circuits","text":"<p>Coding arithmetic circuits in a low-level language bears a significant probability of introducing errors that invalidate the security of the underlying business logic. This can be avoided by using zkFold Symbolic's standard type library as well as any custom types and functions defined on top of it. The developers can focus on the business logic of their application while the compiler takes care of the correctness of the arithmetic circuits.</p> <p>In addition, the zkFold Symbolic compiler is very compact, spanning just a few thousand lines of code, making it easy to audit.</p>"},{"location":"symbolic/introduction/#low-barrier-to-entry","title":"Low barrier to entry","text":"<p>In zkFold Symbolic, developers implement zero knowledge programs, i.e. statements to prove and verify, as pure, polymorphic Haskell functions. The complementing zero knowledge proof protocols are provided as easy-to-use APIs. Thus, in-depth knowledge of the underlying cryptography is not required.</p>"},{"location":"symbolic/introduction/#support-for-the-state-of-the-art-zkp-protocols","title":"Support for the state-of-the-art ZKP protocols","text":"<p>zkFold Symbolic comes with several state-of-the-art zero knowledge proof protocols and circuit construction techniques that work out of the box. Our team is constantly upgrading the existing codebase and adding support for the novel cryptographic primitives as new research comes out.</p>"},{"location":"symbolic/introduction/#use-cases","title":"Use Cases","text":""},{"location":"symbolic/introduction/#large-scale-dapps","title":"Large-scale dApps","text":"<p>For decentralized applications with large transaction volumes, the cost of on-chain transactions can be a significant factor. Symbolic allows developers to create efficient zero knowledge smart contracts and effortlessly take advantage of various transaction batching techniques. This shortens the development cycle and leads to a significant cost reduction for the project and its users.</p>"},{"location":"symbolic/introduction/#complex-on-chain-smart-contracts","title":"Complex on-chain smart contracts","text":"<p>In zero knowledge proof protocols, zkSNARKS in particular, the cost of proof verification is independent (or depends sub-linearly) of the complexity of the statement being proven. This property makes zkSNARKS an ideal medium for implementing complex on-chain smart contracts as the computational burden is shifted from the on-chain verifier to the off-chain prover, i.e. the user or the application backend. In zkFold Symbolic, developers can implement arbitrary complex smart contract logic that can be verified on-chain for a fixed, predictable cost.</p>"},{"location":"symbolic/introduction/#privacy-preserving-applications","title":"Privacy-preserving applications","text":"<p>As the name suggests, zero knowledge proof protocols allow one party to prove to another that a statement is true without revealing any information beyond the validity of the statement. This property is particularly useful in privacy-preserving applications where the user should remain in control of their data. Symbolic provides a high-level language for designing secure data-sharing protocols that can be easily integrated into any application, be it a mobile app, a web service, or a blockchain-based solution.</p>"},{"location":"symbolic/introduction/#verifier-circuits-in-recursive-proof-protocols","title":"Verifier circuits in recursive proof protocols","text":"<p>Recursive proof protocols are particularly difficult to implement due to the need to generate a circuit from the proof verification algorithm. Symbolic simplifies this process as its standard library already contains very efficient in-circuit implementations for many data types and operations used in ZKP protocols. This library can be leveraged to implement custom recursive proof systems with minimal effort.</p>"},{"location":"symbolic/coding/DSL/","title":"Low-level eDSL","text":""},{"location":"symbolic/coding/basic-types/","title":"Basic Types","text":"<p>Here are some of the types from Symbolic Standard Library which you are most likely to encounter while working with the language. All of them implement both <code>SymbolicData</code> and <code>SymbolicInput</code> except for <code>(e -&gt; a)</code>, which is only <code>SymbolicData</code>.</p> <code>Bool c</code> <p>Symbolic datatype corresponding to the usual boolean value. Supports basic boolean operations (<code>&amp;&amp;</code>, <code>||</code>, <code>not</code>, <code>xor</code> etc.) and conditional branching \u2014 as long as the resulting type is <code>SymbolicData</code>:</p> <pre><code>import ZkFold.Symbolic.Data.Conditional  (bool)\nimport ZkFold.Symbolic.Data.Eq           ((==))\nimport ZkFold.Symbolic.Data.FieldElement (FieldElement)\n\nsafeInv :: Symbolic c =&gt; FieldElement c -&gt; FieldElement c -&gt; FieldElement c\nsafeInv default_ x = bool (finv x) default_ (x == zero)\n</code></pre> <p>Located in <code>ZkFold.Symbolic.Data.Bool</code>.</p> <code>FieldElement c</code> <p>Corresponds to a single native field element of a context <code>c</code>. Supports comparison, all field operations and can be obtained from <code>Natural</code>, <code>Integer</code> and from the Haskell value of a native field element (the latter is called <code>BaseField c</code>).</p> <p>Located in <code>ZkFold.Symbolic.Data.FieldElement</code>.</p> <code>ByteString n c</code> <p>Fixed-size bytestring. Supports equality, bitwise logical operations and various operations which treat it as a contiguous sequence of elements (bits): concatenation, reversing, truncation, extension etc.</p> <p>Most operations require <code>KnownNat n</code>, which is to be expected.</p> <p>Located in <code>ZkFold.Symbolic.Data.ByteString</code>.</p> <code>(x, y)</code> <p>As long as both <code>x</code> and <code>y</code> are <code>SymbolicData</code> (<code>SymbolicInput</code>), a pair (and, in general, a tuple) of them is, too.</p> <code>e -&gt; a</code> <p>As long as <code>a</code> is <code>SymbolicData</code>, <code>e -&gt; a</code> is, too. Unfortunately, the same doesn't hold for <code>SymbolicInput</code>, so we currently cannot compile functions which take another function as input; however, thanks to <code>SymbolicData</code> instance, both currying and branching via <code>Bool c</code> work with functions.</p> <code>Vector n x</code> <p>This is our custom \"fixed-size\" vector type. Usually, we use it in an ordinary Haskell code. However, as long as <code>x</code> is <code>SymbolicData</code> (<code>SymbolicInput</code>) and <code>n</code> is <code>KnownNat</code>, a <code>Vector</code> of them is, too.</p> <p>Definition of a <code>Vector</code> can be found in <code>ZkFold.Base.Data.Vector</code>.</p> <code>Maybe c x</code> <p>Symbolic <code>Maybe</code> datatype. As long as <code>x</code> is <code>SymbolicData</code> in context <code>c</code>, <code>Maybe c x</code> is, too, and provides familiar <code>Maybe</code> interface: construnctors <code>just</code>, <code>nothing</code>, as well as <code>maybe</code> combinator.</p> <p>Coming soon</p> <p>While sum types cannot be <code>SymbolicData</code> as-is, soon we will offer a lightweight wrapper which can turn any algebraic datatype containing Symbolic datatypes into their Symbolic counterpart.</p> <code>UInt n r c</code> <p>Fixed-width unsigned integer. Supports comparison, all ring operations which treat it as a residue modulo <code>2^n</code> and can be obtained from <code>Natural</code>, <code>Integer</code> and from <code>FieldElement c</code> as long as <code>n</code> is big enough.</p> <p><code>r</code> is a register size which can be tweaked in different usecases for maximum performance. Can be set either to <code>Auto</code> which greedily chooses biggest registers or to <code>Fixed m</code> where <code>m</code> is fixed number of bits in a register.</p> <p>Most operations require <code>KnownNat (NumberOfRegisters (BaseField c) n r)</code>.</p> <p>Located in <code>ZkFold.Symbolic.Data.UInt</code>.</p> <p>Coming soon</p> <p>Actually, using <code>NumberOfRegisters</code> slows down compilation of Haskell code quite a bit and also hurts readability, so we are going to get rid of this constraint soon and only require <code>KnownNat n</code> and <code>KnownRegisterSize r</code>.</p> <code>FFA p c</code> <p>Foreign-field arithmetic modulo <code>p</code> inside arbitrary context <code>c</code>. Currently only ring operations are supported.</p> <p>Located in <code>ZkFold.Symbolic.Data.FFA</code>.</p> <p>Coming soon</p> <p>Soon, we will migrate FFA to more efficient implementation, which would also allow for exact equality and fast exponentiation.</p> <code>Point (Ed25519 c)</code> <p>Point of an Edwards 25519 curve as a Symbolic datatype. Supports basic curve operations.</p> <p>Coming soon</p> <p>Currently we are in an active process of integrating Incrementally Verifiable Computations (IVCs) into zkFold Symbolic. Based on this technique, soon we will be able to provide arbitrarily-sized types for Symbolic, including <code>List</code>s, arbitrary-sized <code>ByteString</code>s, arbitrary-precision arithmetic and more!</p>"},{"location":"symbolic/coding/custom-types/","title":"Custom Types","text":""},{"location":"symbolic/coding/getting-started/","title":"Getting Started","text":""},{"location":"symbolic/coding/getting-started/#symbolic-fundamentals","title":"Symbolic Fundamentals","text":"<p>zkFold Symbolic doesn't rely on any GHC compiler magic or compiler plugins: Symbolic code is usual Haskell code, compiled by usual GHC 9.6.0 compiler. We only use the Haskell type system in a smart way to distinguish arithmetizable computations from non-arithmetizable ones. While this is great, this also means that at least basic knowledge of Haskell language is required; we advise to at least get comfortable with the syntax first.</p> <p>Now, back to Symbolic. It is distinguished from simple Haskell by presence of the context type variable <code>c</code> satisfying the type constraint <code>Symbolic c</code> which is later used in Symbolic data types. For example, here is the Symbolic function which, given a native field element and a <code>ByteString</code> of length 256, computes MiMC hash on the contents of a bytestring and compares it with the expected result:</p> <pre><code>{-# LANGUAGE DataKinds         #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport ZkFold.Symbolic.Algorithms.Hash.MiMC (hash)\nimport ZkFold.Symbolic.Class                (Symbolic)\nimport ZkFold.Symbolic.Data.Bool            (Bool)\nimport ZkFold.Symbolic.Data.ByteString      (ByteString)\nimport ZkFold.Symbolic.Data.Eq              ((==))\nimport ZkFold.Symbolic.Data.FieldElement    (FieldElement)\n\ncheckHash :: Symbolic c =&gt; FieldElement c -&gt; ByteString 256 c -&gt; Bool c\ncheckHash expected byteString = hash byteString == expected\n</code></pre> <p>Coming soon</p> <p>If you too are worried by the amount of the <code>import</code> stanzas, you are not alone. Soon we will define the <code>ZkFold.Symbolic.Prelude</code> module which would reexport the most useful definitions of Symbolic Standard Library.</p> <p>The main benefit of making all functions polymorphic in <code>c</code> is that it allows us to reinterpret them in a plethora of different ways, most notably both as a blueprint for an arithmetic circuit used in a zkSNARK and as a pure function to be evaluated on concrete inputs.</p> <p>While there is no restriction on which functions can be written and reused in other functions (as zkFold Symbolic code is just Haskell code), for a function to be compilable into a circuit, certain conditions have to be satisfied:</p> <ol> <li>All of its arguments are an instance of <code>SymbolicInput</code>;</li> <li>Its return type is <code>SymbolicData</code>.</li> </ol> <p><code>checkHash</code> satisfies these constraints, so we can compile it with, you guessed it, <code>compile</code> function and print the compiled circuit:</p> <pre><code>import ZkFold.Symbolic.Compiler (compile)\nimport MyExample                (checkHash)\n\nprintCheckHashAC :: IO ()\nprintCheckHashAC = print (compile checkHash)\n</code></pre> <p>Our Standard Library provides a collection of basic types with instances of both <code>SymbolicInput</code> and <code>SymbolicData</code>. Basic types are covered on the next page of this documentation. When building on top of those basic types, developers can write down their own instances of <code>SymbolicInput</code> and <code>SymbolicData</code> for their custom types. We will discuss custom type implementation on the Custom Types page.</p>"},{"location":"symbolic/coding/getting-started/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"symbolic/coding/getting-started/#higher-order-functions","title":"Higher-order functions","text":"<p>Being usual Haskell code, zkFold Symbolic admits usual Haskell idioms, including polymorphism, monads, higher-order functions and whatnot. For example, we could rewrite our <code>checkHash</code> function in the following way:</p> <pre><code>import ZkFold.Symbolic.Algorithms.Hash.MiMC qualified as MiMC\n\ncheckWith ::\n    Symbolic c =&gt;\n    FieldElement c -&gt; (ByteString c -&gt; FieldElement c) -&gt; ByteString c -&gt; Bool c\ncheckWith expected hash byteString = hash byteString == expected\n\ncheckHash :: Symbolic c =&gt; FieldElement c -&gt; ByteString c -&gt; Bool c\ncheckHash expected = checkWith expected MiMC.hash\n</code></pre> <p>And this would still compile just fine \u2014 and to the same circuit as before, even \u2014 nevermind the higher-order functions and eta-reduction. Once again: anything goes as long as the function which ends up being compiled satisfies the constraints outlined above.</p>"},{"location":"symbolic/coding/getting-started/#embedding-haskell-values","title":"Embedding Haskell values","text":"<p>While there is typically no way to obtain the value of a Symbolic datatype inside a Symbolic function (because, in an arbitrary context, there might be no such thing as \"value\" to worry about, at all), going in the other direction is dead simple: just call the conversion function! At zkFold, we call this conversion function <code>fromConstant</code>.</p> <p>Now, for a final version of a <code>checkHash</code>:</p> <pre><code>import Numeric.Natural                 (Natural)\n\nimport ZkFold.Base.Algebra.Basic.Class (FromConstant (..))\n\ncheckWith' ::\n    (Symbolic c, FromConstant a (FieldElement c)) =&gt;\n    a -&gt; (ByteString c -&gt; FieldElement c) -&gt; ByteString c -&gt; Bool c\ncheckWith' expected hash byteString = hash byteString == fromConstant expected\n\ncheckHash' :: Symbolic c =&gt; ByteString c -&gt; Bool c\ncheckHash' = checkWith' (0xDEADF00D :: Natural) MiMC.hash\n</code></pre> <p>Few things to note:</p> <ol> <li>As can be expected from its type, <code>checkHash'</code> compiles fine, too.</li> <li>As provided <code>expected</code> value is constant, it can (and will) be encoded in the    circuit using fewer constraints, bringing further optimizations!</li> </ol> <p>Danger</p> <p>As always is with sensitive information, care must be taken: do not use this technique to encode private values inside the circuit! Anyone who gets to view the contents of the circuit can extract the information easily.</p>"},{"location":"symbolic/smart-contracts/basics/","title":"Zero Knowledge Smart Contracts","text":""},{"location":"symbolic/smart-contracts/symbolic-ledger/","title":"ZK Smart Contracts on the Symbolic Ledger","text":""},{"location":"symbolic/smart-contracts/cardano/","title":"ZK Smart Contracts on Cardano","text":""},{"location":"symbolic/smart-contracts/cardano/#overview","title":"Overview","text":""},{"location":"symbolic/smart-contracts/cardano/#types-of-smart-contracts","title":"Types of Smart Contracts","text":""},{"location":"symbolic/smart-contracts/cardano/#plonk-verifier","title":"Plonk Verifier","text":""},{"location":"symbolic/smart-contracts/cardano/#symbolic-verifier","title":"Symbolic Verifier","text":""},{"location":"symbolic/smart-contracts/cardano/plonk-verifier/","title":"Plonk Verifier Tokens","text":""},{"location":"symbolic/smart-contracts/cardano/plonk-verifier/#overview","title":"Overview","text":"<p>Plonk Verifier script is a Plutus script (minting policy) that enables minting of tokens based on the verification of a Plonk proof. The statement that is being verified is encoded into the script parameter: different statements correspond to different minting policies. This statement must be expressed as a Plonk arithmetic circuit and must contain a single public parameter belonging to the scalar field of BLS12_381 elliptic curve. The Plonk Verifier script execution succeeds in two cases: - when the tokens are being burned, or - when the Plonk proof is valid and the minted token's name is the byte representation of the public input.</p>"},{"location":"symbolic/smart-contracts/cardano/plonk-verifier/#type-signature","title":"Type Signature","text":"<p>Plonk Verifiers allow developers to ask the network to verify essentially any statement. Using the zkFold Symbolic framework, developers can express these statements as Haskell functions with the following type signature:</p> <pre><code>statement :: (Symbolic c, SymbolicData x) =&gt; FieldElement c -&gt; x -&gt; Bool c\n</code></pre>"},{"location":"symbolic/smart-contracts/cardano/plonk-verifier/#usage","title":"Usage","text":"<p>A Plonk Verifier token corresponds to a combination of a statement (minting policy) and a public input (token name). The mere existence of such a token on the blockchain is a proof that the statement with the corresponding public input has been verified by the network.</p> <p>These tokens can be used in various scenarios, such as gating access to a service or a resource, both off-chain or on-chain. For example, a token can be minted if a user has completed a registration process on a platform. In this case, the public input could be the hash of user data. The token can then allow the user to prove (parts of) their data selectively to other parties.</p>"},{"location":"symbolic/smart-contracts/cardano/symbolic-verifier/","title":"Smart Contracts with Symbolic Verifier","text":""},{"location":"symbolic/smart-contracts/cardano/symbolic-verifier/#overview","title":"Overview","text":"<p>Cardano Type Library facilitates zero knowledge smart contracts on Cardano.</p> <p>Cardano nodes are capable of executing code written in Untyped Plutus Core (UPLC), a low-level functional programming language. On the other hand, zero knowledge smart contracts can be represented by arithmetic circuits, a mathematical formalism that is used to describe true/false statements about some \"public data\". To verify a zero knowledge smart contract, we run the <code>verify</code> algorithm against the hash of transaction data, the commitment to a Plonk arithmetic circuit, and the corresponding zero knowledge proof. If the verification passes, the network participants can be sure that the transaction satisfies the respective zkFold Symbolic smart contract.</p>"},{"location":"symbolic/smart-contracts/cardano/symbolic-verifier/#type-signature","title":"Type Signature","text":"<p>All zkFold Symbolic smart contracts are Haskell pure functions of transaction data and some auxiliary data. This auxiliary data usually consists of private information available to the parties involved in the transaction. It does not need to be posted on the blockchain.</p> <pre><code>smartContract :: Transaction a -&gt; AuxiliaryData a -&gt; Bool a\n</code></pre> <p>Type <code>Transaction</code> is a part of our Cardano Type Library. On the other hand, <code>AuxiliaryData</code> is a type defined by the smart contract developer.</p>"},{"location":"symbolic/smart-contracts/cardano/transactions/","title":"Transactions with Symbolic Smart Contracts","text":""},{"location":"symbolic/smart-contracts/cardano/transactions/#building-transactions","title":"Building Transactions","text":"<p>Symbolic Framework provides two ways of constructing smart contract transactions: through a backend component API or through JavaScript library functions.</p> <p>Transaction building routine proceeds as follows:</p> <ol> <li>Build an unbalanced transaction satisfying the smart contract.</li> <li>Estimate the fees, including the proof verification script.</li> <li>Balance the transaction using the mock redeemer for the proof verification script.</li> <li>Calculate the proof.</li> <li>Modify the redeemer to include the correct proof.</li> <li>Submit the transaction.</li> </ol> <p>ZKFold off-chain APIs cover steps 2-5 of this process. Step 1 is usually implemented either by DApp developers or 3rd-party tools that build smart contract transactions from schemas.</p>"},{"location":"symbolic/tools/circom-converter/","title":"Circom Converter","text":""},{"location":"symbolic/tools/cli/","title":"Symbolic CLI","text":""},{"location":"symbolic/tools/uplc-converter/","title":"UPLC Converter","text":""},{"location":"symbolic/tools/uplc-converter/#overview","title":"Overview","text":"<p>UPLC Converter is a tool that transpiles Untyped Plutus Core (UPLC) scripts to arithmetic circuits. It makes it possible to use UPLC scripts in the zkFold Symbolic framework on par with Symbolic smart contracts.</p> <p>According to the Plutus Core specification, a UPLC program is a tree where nodes are UPLC terms. UPLC Converter recursively traverses the UPLC program and converts each term to the corresponding zkFold Symbolic expression. </p> <p>The resulting Haskell expression is then converted to an arithmetic circuit using the zkFold Symbolic framework. The circuit outputs <code>1</code> if and only if the UPLC program executes successfully on the given input.</p>"},{"location":"symbolic/tools/uplc-converter/#specification","title":"Specification","text":"<p>In this section, we describe the rules for converting UPLC terms to arithmetic circuits.</p>"},{"location":"symbolic/tools/uplc-converter/#variables","title":"Variables","text":"<p>UPLC<pre><code>x\n</code></pre> Every variable must first be defined in a \\(\\lambda\\)-abstraction term. When we encounter a variable term, we look up the associated <code>SymbolicData</code> object in the environment that is defined as a <code>Map</code>.</p> Haskell<pre><code>x :: SymbolicData x =&gt; Map Natural x -&gt; Natural -&gt; x\n</code></pre>"},{"location":"symbolic/tools/uplc-converter/#constants","title":"Constants","text":"UPLC<pre><code>(con T c)\n</code></pre> <p>Every constant in UPLC is constructed using the predefined built-in types and type operators. All those types and type operators have their counterparts in Haskell base library. Thus, constants can be converted to <code>SymbolicData</code> objects using the <code>fromConstant</code> function.</p> Haskell<pre><code>con :: (FromConstant a x, SymbolicData x) =&gt; a -&gt; x\ncon = fromConstant\n</code></pre>"},{"location":"symbolic/tools/uplc-converter/#built-in-functions","title":"Built-in functions","text":"UPLC<pre><code>(builtin b)\n</code></pre> <p>Every version of UPLC has a fixed set of built-in functions. We can, therefore, define zkFold Symbolic counterparts for each of them. For example, a UPLC built-in function <code>ifThenElse</code> is converted to the function of the same name in zkFold Symbolic.</p> Haskell<pre><code>ifThenElse :: (Symbolic c, SymbolicData x, Context x ~ c) =&gt; Bool c -&gt; x -&gt; x -&gt; x\n</code></pre>"},{"location":"symbolic/tools/uplc-converter/#lambda-abstraction","title":"\\(\\lambda\\)-abstraction","text":"UPLC<pre><code>(lam x M)\n</code></pre> <p>Lambda abstraction term adds a new variable to the environment and converts the body of the lambda term.</p> Haskell<pre><code>lam :: (SymbolicData x, SymbolicData y) =&gt; (x -&gt; y) -&gt; x -&gt; y\n</code></pre>"},{"location":"symbolic/tools/uplc-converter/#function-application","title":"Function application","text":"UPLC<pre><code>[M N]\n</code></pre> <p>Function application term simply converts to the function application in Haskell.</p> Haskell<pre><code>m :: (SymbolicData x, SymbolicData y) =&gt; x -&gt; y\n\nn :: SymbolicData x =&gt; x\n\nm n :: SymbolicData y =&gt; y\n</code></pre>"},{"location":"symbolic/tools/uplc-converter/#delay-and-force","title":"Delay and force","text":"UPLC<pre><code>(delay M)\n\n(force M)\n</code></pre> <p>Delay and force implement type abstraction and type application in UPLC. They are skipped during the conversion process.</p>"},{"location":"symbolic/tools/uplc-converter/#error","title":"Error","text":"UPLC<pre><code>(error)\n</code></pre> <p>Unlike with other terms, the error term cannot be directly converted to an expression in a statically typed language, such as Haskell. For example, in UPLC it can be used as an argument to a function that expects an integer or a list making it impossible to assign a type to such expression. The explicit usage of the error term is tricky for smart contract developers as the UPLC program may output an unexpected result due to the fact that the evaluation order is not clear from the program representation in a high-level language such as Aiken or PlutusTx. Luckily for us, the only real purpose of this term is to save some execution units for the Plutus CEK machine, which do not matter in the ZK smart contract verification. As a result, we prefer to explicitly forbid the usage of the error term in the convertible UPLC programs.</p>"},{"location":"symbolic/tools/uplc-converter/#cli-commands","title":"CLI Commands","text":"<p>Below we provide the list of available commands for UPLC Converter.</p>"},{"location":"symbolic/tools/uplc-converter/#convert-uplc-to-circuit","title":"Convert UPLC to Circuit","text":"<pre><code>uplc-converter circuit &lt;input-file&gt; &lt;output-file&gt;\n</code></pre> <p>The command expects the path to the input UPLC script in CBOR and the path to the output zkFold Circuit file. The output file will contain the generated arithmetic circuit.</p>"},{"location":"symbolic/tools/uplc-converter/#convert-a-plutus-v3-script-to-a-symbolic-verifier-script","title":"Convert a Plutus V3 Script to a Symbolic Verifier Script","text":"<pre><code>uplc-converter symbolic-script &lt;input-file&gt; &lt;output-file&gt;\n</code></pre> <p>This command converts a Plutus V3 script to a Symbolic Verifier script. The input file should be a zkFold Circuit file, and the output file will contain the symbolic verifier script in CBOR.</p>"},{"location":"symbolic/tools/uplc-converter/#generate-a-forwarding-script","title":"Generate a Forwarding Script","text":"<pre><code>uplc-converter forwarding-script &lt;input-file&gt; &lt;output-file&gt;\n</code></pre> <p>This command generates a forwarding script that forwards the validation to the given UPLC script. The input file should be a zkFold Circuit file, and the output file will contain the symbolic verifier script in CBOR.</p>"}]}